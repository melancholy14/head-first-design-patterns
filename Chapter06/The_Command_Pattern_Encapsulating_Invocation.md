# Chapter 6

## 호출 캡슐화하기: 커맨트 패텬

### 만능 IOT 리모컨

프로그래밍이 가능한 7개의 슬롯이 있는 리모콘이 있습니다. 각 슬롯에는 ON, OFF 버튼이 있어서 연결된 가전제품을 제어할 수 있죠. 마지막으로 누른 버튼의 명령을 취소하는 undo 버튼도 있습니다.\
다만, 각 슬롯에 들어가는 가전제품들의 클래스는 제각각의 인터페이스들을 갖고 있네요. 추가될 가전제품들도 믿을 수 없습니다.

### 커맨드 패턴 소개

#### 객체마을 식당

음식을 주문한다고 가정해보죠.

고객이 원하는 것을 주문합니다 (createOrder) &rarr; 주문(Order)은 주문서와 주문 내용으로 구성됩니다 &rarr; 종업원이 주문서를 가져옵니다 (takeOrder) 그리고 주문 처리를 준비하죠 (orderUp) &rarr; 주문 객체(Order)에는 음식 준비에 필요한 모든 지시사항이 적혀 있어 주방장에게 지시할 수 있습니다 &rarr; 주방장이 음식을 준비합니다.

#### 커맨드 패턴

위 음식 주문을 커맨드 패턴에 적용할 수 있습니다.

클라이언트가 커맨드 객체를 생성합니다 (createCommandObject) &rarr; 커맨드 객체에는 행동과 리시버의 정보가 함께 들어있습니다 &rarr; 클라이언트가 인보커 객체를 호출하고요 (Invoker.setCommand) 그리고 인보커는 전달받은 커맨드 객체의 메소드를 실행합니다 (Command.execute) &rarr; 커맨드 객체에는 리시버의 정보가 있어 리시버에게 어떤 행동을 할지 호출할 수 있습니다 &rarr; 리시버의 메소드가 호출되어 행동을 실행합니다.

### 일단 만들어봅시다

[codes/RemoteControlTest.ts](./codes/RemoteControlTest.ts) 코드 참고

### 커맨드 패턴의 정의

```text
// 커맨드 패턴 (Command Pattern)
요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있습니다. 이러면 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수 있습니다.
```

1. <<인터페이스>> Command: 모든 커맨드 객체에서 구현해야하는 인터페이스. 명령을 호출하는 execute()가 포함
2. ConcreteCommand: Command 구현 클래스. execute()를 호출하여 리시버의 메소드를 호출할 수 있도록 연결.
3. Receiver: 요구 사항을 수행할 때 특정 행동을 처리하는 객체
4. Invoker: execute()를 호출하여 커맨드 객체에게 특정 작업을 수행하라 요구하는 객체
5. Client: ConcreteCommand를 생성하고 Receiver를 설정하는 객체

### 슬롯에 명령 할당하기

[codes/RemoteLoader.ts](./codes/RemoteLoader.ts) 코드 참고

#### 람다 표현식을 써서 고친 코드

자바의 람다 표현식을 쓰면 구상 커맨드 객체의 인스턴스를 생성하는 대신 함수 객체를 사용할 수 있습니다.

[codes/RemoteLoaderWithLambda.ts](./codes/RemoteLoaderWithLambda.ts) 코드 참고

(Lambda 라기보단.. Arrow function으로 흉내내봤지만 커맨드 객체를 분리한 의미가 사라지는 것 같음..)

### 작업 취소 기능 추가하기

커맨드 인터페이스에 `undo()` 메소드가 있어야 합니다.

[codes/RemoteControlWithUndo.ts](./codes/RemoteControlWithUndo.ts) 코드 참고

선풍기와 같이 속도를 선택할 수 있는 경우는 어떨까요? 이전 상태를 기억해야하는 케이스는 간단한 상태를 저장하면 됩니다.

[codes/CeilingFanHighCommand.ts](./codes/CeilingFanHighCommand.ts) 코드 참고

### 여러 동작을 한 번에 처리하기

여러 가지 커맨드를 한 번에 실행할 수 있는 커맨드는 어떨까요?

[codes/RemoteLoaderWithMacro.ts](./codes/RemoteLoaderWithMacro.ts) 코드 참고

### 커맨드 패턴 활용하기

1. 작업 큐
    - 큐 한 쪽 끝은 커맨드를 추가할 수 있도록 되어 있고, 다른 쪽 끝에는 커맨드를 처리하는 스레드들이 대기하고 있습니다.
    - 각 스레드는 우선 execute() 메소드를 호출하고 호출이 완료되면 커맨드 객체를 버리고 새로운 커맨드 객체를 가져옵니다.
2. 로깅하기
    - 모든 행동을 기억해두었다가 애플리케이션이 다운되었을 때 그 행동을 다시 호출해서 복구할 수 있어야 할 때.
    - 커맨드 객체에 store(), load() 메소드 추가하여 구현할 수 있습니다.
    - 각 커맨드가 실행될 때마다 디스크에 내역 저장 &rarr; 다운되었다면? &rarr; 디스크에 저장된 내역의 객체를 다시 로딩해서 순서대로 작업을 다시 처리

## 핵심 정리

- 커맨드 패턴을 사용하면 요청하는 객체와 요청을 수행하는 객체를 분리할 수 있습니다.
- 이렇게 분리하는 과정의 중심에는 커맨드 객체가 있으며, 이 객체가 행동이 들어있는 리시버를 캡슐화합니다.
- 인보커는 무언가 요청할 때 커맨드 객체의 execute() 메소드를 호출하면 됩니다.
- 커맨드는 인보커를 매개변수화할 수 있습니다. 실행 중에 동적으로 매개변수화를 설정할 수도 있습니다.
- execute() 메소드가 마지막으로 호출되기 전의 상태로 되돌리는 작업 취소 메소드를 구현하면 커맨드 패턴으로 작업 취소 기능을 구현할 수도 있습니다.
- 매크로 커맨드는 커맨드를 확장해서 여러 개의 커맨드를 한 번에 호출할 수 있게 해주는 가장 간편한 방법입니다. 매크로 커맨드도 어렵지 않게 작업 취소 기능을 구현할 수 있습니다.
- 프로그래밍을 하다 보면 요청을 스스로 처리하는 '스마트' 커맨드 객체를 사용하는 경우도 종종 있습니다.
- 커맨드 패턴을 활용해서 로그 및 트랜잭션 시스템을 구현할 수 있습니다.
